# Chapter 3 : 애그리거트

- [Aggregate](#Aggregate)
- [Aggregate Root](#Aggregate-Root)
- [Repository와 Aggregate](#Repository와-Aggregate)
- [ID를 이용한 Aggregate 참조](#ID를-이용한-Aggregate-참조)
  - [애그리거트를 직접 참조했을 때의 문제](#애그리거트를-직접-참조했을-때의-문제)
- [Aggregate를 Factory로 사용하기](#Aggregate를-Factory로-사용하기)
- [💡 생각해볼 점](#-생각해볼-점) 

<br/>

## Aggregate  
- `상위 수준 개념`을 이용하여 전체 모델을 정리하면 `전반적인 도메인 간의 관계를 이해`하기 쉬워짐 + `복잡도가 낮아짐`   
  -> `일관성 관리`에 도움이 됨 + 도메인 기능을 `확장하고 변경`하는 데 필요한 노력(개발 시간)이 줄어듬     

  - 주요 도메인 개념 간의 관계를 파악하기 어렵다 = 코드를 변경하고 확장하는 것이 어렵다
- 주의할 점
  - `한 애그리거트`에 `2개이상의 엔티티`가 존재하게 되면 잘못 구성한 것
  - `A가 B를 갖는다`로 설계 가능한 요구사항이 있어도 이것이 반드시 A와 B가 한 애그리거트에 속한다는 것을 의미 하는 것 아님   

<br/>

## Aggregate Root   
- Aggregate Root : aggregate에 속해 있는 객체들을 관리함
- Aggregate Root의 핵심 역할 : `aggregate의 일관성이 깨지지 않도록 하는 것`

  - `aggregate root를 통해서만 도메인 로직 구현`하기 & `aggregate 내부의 다른 객체를 조합`해서 기능 완성
  
  - aggregate root가 아닌 다른 객체(외부)가 aggregate에 속한 객체를 직접 변경하면 -> 일관성이 깨지게 됨
  
    - 여기저기서 변경하면 관리 어렵고 확장도 힘듬
  
  - `밸류에 대해서 불변 타입`으로 관리하는것 추천
  
  - 단순히 `필드를 변경하는 set 메서드를 공개(public) 범위로 만들지 않는것` 추천   

<br/>

## Repository와 Aggregate     
- 객체의 영속성을 처리하는 `repository는 애그리거트 단위로` 존재 + `트랜잭션 사용`하여 ACID 관리
  
<br/>

## ID를 이용한 Aggregate 참조   
- 다른 aggregate를 참조하기 위해 `다른 aggregate의 root를 참조`한다는 것
  - 한 객체가 다른 객체를 참조하는 것처럼 `aggregate도 다른 aggregate를 참조`함

  - aggregate 간의 참조는 `field를 통해` 쉽게 구현 = 애그리거트를 직접 참조
    - JPA를 사용하면 @ManyToOne, @OneToOne 과 같은 annotation을 이용해서 연관된 객체를 로딩하는 기능 제공      
       -> 필드를 이용해 다른 aggregate를 쉽게 참조 가능    
  
    => 그러나, 이 방법에는 여러 문제점들이 있음   

<br/>

### 애그리거트를 직접 참조했을 때의 문제    

1. `편한 탐색 오용`    
: 한 aggregate 내부에서 다른 aggregate 객체에 접근할 수 있으면 `다른 aggregate 상태를 쉽게 변경`할 수 있게 됨    
-> 구현의 편리함으로 인해 고민하게 됨     

2. `성능에 대한 어려움`   

3. `확장 어려움`   
: 만약 하위 도메인마다 `서로 다른 DBMS`를 사용하게 되면?    
= 다른 aggregate 루트를 참조하기 위해 JPA와 같은 단일 기술을 시용할 수 없음을 의미   

  => 해결하기 위해 `ID를 이용해 간접 참조`를 사용하자      

<br/>

- `ID 참조`는 `모든 객체가 참조로 연결되지 않고` `한 aggreagate에 속한 객체들만 참조로 연결`됨
  
  => ID 참조를 통해서 결합도를 낮추고 응집도를 높이자    

<br/>

- 하지만, ID 참조가 마냥 좋은 점만 있는것은 아님
   
  - 조회시 `N+1 문제` 야기
    
    - N+1 발생하지 않도록 조인이나 조회 전용 쿼리를 사용하자

<br/>

## Aggregate를 Factory로 사용하기     
- `aggregate가 갖고 있는 데이터를 이용`해서 `다른 aggregate를 생성`해야 한다면 `aggregate에 factory method를 구현`하는 것 고려해보기
    
  - 대상 aggregate의 데이터 일부를 직접 제공하면서 `생성할 aggregate의 도메인 로직을 함께 구현`할 수 있게 됨
    
    - ex) 온라인 쇼핑몰에서 고객이 여러 차례 신고를 해서 특정 상점이 더 이상 물건을 등록하지 못하도록 차단된 상태
      
      `상품 등록 기능을 구현한 응용 서비스`는 `상점 계정이 차단 상태가 아닌 경우에만 상품을 생성`하도록 구현할 수 있음
       
      = `차단상태 확인 → 상품 생성`하는 것은 `논리적으로 하나의 도메인 기능`     
    
<br/>

## 💡 생각해볼 점   
- '객체의 영속성을 처리하는 `repository는 애그리거트 단위로` 존재한다.' 부분에서 최근에 JPA만 사용했더니 이부분서 잠깐 잉?했다      
  왜냐면 JPA에서는 엔티티가 RDB 기준의 엔티티라 그에 따른 repository layer가 필요하니까,,         
  무엇을 의미하는지는 알겠는데 구현부분에서는 안그려진다 좀 더 읽어보기   

- 내가 이해한 3장
  - 도메인간의 관계 파악과 일관성 유지를 위해 외부에서 aggreagate에 속한 객체를 변경하면 안되며,    
    aggreagate root라는 주체를 통해서 상태나 기능들을 관리해야 한다    

<br/>
