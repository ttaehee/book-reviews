# Chapter 6 : 응용 서비스와 표현 영역

- [응용 서비스의 역할](#응용-서비스의-역할)
- [응용 서비스의 구현](#응용-서비스의-구현)
  - [응용 서비스 구현 방식](#응용-서비스-구현-방식)
  - [응용 서비스의 크기](#응용-서비스의-크기)
  - [응용 서비스의 인터페이스와 클래스](#응용-서비스의-인터페이스와-클래스)
  - [표현 영역에 의존하지 않기](#표현-영역에-의존하지-않기)
- [트랜잭션 처리](#트랜잭션-처리)
  - [도메인 이벤트 처리](#도메인-이벤트-처리)
- [표현 영역](#표현-영역)
  - [값 검증](#값-검증)
  - [권한 검사](#권한-검사)  
- [💡 생각해볼 점](#-생각해볼-점) 

<br/>

- 도메인이 제 기능을 하려면 `사용자와 도메인을 연결`해주는 매개체가 필요   
  => 응용 영역, 표현 영역

<br/>

- `표현 영역`
  - 사용자의 요청을 해석 (HTTP요청)
  - 응용 서비스의 실행 결과를 형식에 맞게 응답 (HTML, JSON)   
- `응용 영역`
  - 실제 사용자가 원하는 기능 제공

<br/>

## 응용 서비스의 역할
- 도메인 객체를 사용해 `사용자의 요청을 처리`   
- 도메인 영역과 표현 영역을 `연결`
- `transaction` 처리

<br/>

- `응용 서비스가 복잡`하다면 응용 서비스에서 도메인 로직을 구현하고 있을 가능성이 있음    
  = 도메인 로직을 도메인 영역과 응용서비스에 분산해서 구현하면      
  
  -> 코드 품질에 문제 발생    
  코드의 응집성이 떨어지고, 응용 서비스에서 동일한 도메인 로직을 구현할 가능성이 높아짐

  -> `코드 변경`이 어려워짐    

  => 소프트웨어의 가치를 높이려면 -> `도메인 로직을 도메인 영역에 모아서` 코드 중복을 방지하고 응집도를 높여야함    

<br/>

## 응용 서비스의 구현

### 응용 서비스 구현 방식
- 보통 다음의 두 가지 방법 중 한 가지 방식으로 구현함   

1. 한 응용 서비스 클래스에 회원 `도메인의 모든 기능` 구현
    - 장점 : 동일 코드에 대한 중복 로직을 private method 호출을 통해 제거 가능
    - 단점 : 한 서비스 클래스의 크기가 커짐, 관련 없는 코드가 뒤섞여 코드 이해를 방해함

2. 구분되는 `기능별로` 응용 서비스 클래스를 따로 구현
    - 장점 : 코드 품질을 일정 수준으로 유지하는 데 도움을 줌
    - 단점 : 클래스 개수가 많아짐, 클래스의 기능이 분산되어 중복 코드를 구현할 가능성이 있음    
      -> 공통되는 로직을 별도 클래스에 구현하여 코드 중복을 방지할 수 있음

<br/>

### 응용 서비스의 크기
- 응용 서비스를 구현할때, 응용서비스의 크기 고려 필요

<br/>

### 응용 서비스의 인터페이스와 클래스
- 응용 서비스를 구현할 때의 논쟁 : `interface의 필요 여부`
  - interface가 필요한 경우   
    - `구현 클래스가 다수 존재` or `런타임에 구현 객체를 교체`해야 할 경우
    - `표현 영역에서 단위 테스트`를 위해 응용 서비스 클래스의 가짜 객체가 필요할 경우 (Mockito를 사용할 경우엔 필요없음)

<br/>

```
저자는 interface를 작성에 긍정적이진 않다(소스 파일만 많아지고 전체 구조만 복잡해지는 문제)   
interface가 명확하게 필요한 이유가 있는 경우 사용하자고(동의!)   
근데 의존성은 떨어트리라구,,(말로는 참 쉬운 그것,,)          
```

<br/>

### 표현 영역에 의존하지 않기
- 응용 서비스의 파라미터 타입 결정 시, 표현 영역과 관련된 타입 사용하면 안됨
  - ex) HttpServletRequest와 같이 표현 영역에서 사용되는 클래스를 응용 서비스 영역의 파라미터로 전달하면 안됨

<br/>

- 응용 서비스에서 표현 영역에 대한 의존이 발생하면~
  
  - 응용 서비스만 단독으로 테스트하기가 어려워짐
  - 표현 영역의 구현이 변경되면 응용 서비스의 구현도 함께 변경되야 함
  - 응용 서비스가 표현 영역의 역할까지 대신하는 상황이 나타날 수도 있음

<br/>

## 트랜잭션 처리
### 도메인 이벤트 처리
- 도메인에서 이벤트를 발생시키면, 그 이벤트를 받아서 처리하는 역할(알맞은 후처리)을 하는 것이 응용 서비스    
  - 코드가 다소 복잡
  - 도메인 간의 의존성이나 외부 시스템에 대한 의존을 낮춰줌
  - 시스템을 확장하는 데에 이벤트가 핵심 역할을 수행하게 됨   
    
<br/>

## 표현 영역
### 값 검증
- 표현 : 필수 값, 값 형식, 범위 등 `단순한 입력값`에 대한 검증
- 응용 : 데이터 존재 유무 등 `논리적 오류`에 대한 검증

<br/>

### 권한 검사
- 권한 검사는 표현, 응용서비스, 도메인에서 가능

  - 표현 : `인증된 사용자 여부` 검사
    - 접근 제어를 하기에 좋은 위치가 servlet filter

  - 응용 : URL 만으로 접근 제어를 할 수 없는 경우 -> 응용 서비스의 method 단위로 권한 검사 수행
    - spring security의 AOP 활용
      - ex) `@PreAuthorize("hasRole('ADMIN')")`

  - 개별 도메인 객체단위 : 권한검사 로직 구현 필요
    - ex) 게시글 삭제는 본인이 작성한 것만 가능

<br/>

## 조회 전용 기능과 응용 서비스
- 서비스 없이 표현 영역에서 바로 사용해도 문제가 없는 경우
  - 서비스에서 수행하는 추가 로직이 없고
  - 단일 쿼리만 실행하는 조회 전용으로
  - 트랜잭션이 필요하지 않고
  - 사용자 요청기능을 실행하는 데 별다른 기여를 하지 않는 경우

<br/>

## 💡 생각해볼 점

- 저자는 조회 전용 기능만 있는 경우, 굳이 `서비스 레이어 없이 표현 영역에서 바로 조회 전용 기능을 사용`해도 된다고 말하나         
  `조회 기능에 대한 변경 대응을 유연`하게 하려면 + 전체적인 `레이어 통일성` + 서비스 로직의 `단위 테스트`를 통해 조회 전용 기능을 사용하고 있음을 명시하기 위해   
  `서비스를 두는게 좋을 것 같다`는 생각이 들었다     
  물론 팀끼리 약속이 되어 있다면 상관없겠지만    

- 내가 이해한 6장
  - 표현 영역과 응용 서비스의 차이에 대한 기준을 명확히 해두고 구현하자    

<br/>
