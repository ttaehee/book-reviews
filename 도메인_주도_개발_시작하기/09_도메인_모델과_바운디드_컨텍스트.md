# Chapter 9 : 도메인 모델과 바운디드 컨텍스트

- [바운디드 컨텍스트](#바운디드-컨텍스트)
  - [구현](#구현)
  - [통합 방식](#통합-방식) 
  - [바운디드 컨텍스트 간 관계](#바운디드-컨텍스트-간-관계)
- [컨텍스트 맵](#컨텍스트-맵)
- [💡 생각해볼 점](#-생각해볼-점) 

<br/>

## 바운디드 컨텍스트
- 도메인 모델을 만들 때 빠지기 쉬운 함정 : 도메인을 완벽하게 표현하는 단일 모델을 만드는 시도를 하는 것
- `하위 도메인마다 사용하는 용어가 다름` -> 올바른 도메인모델 개발을 위해선 하위 도메인마다 모델을 만들어야 함       
  - 모델은 특정한 컨텍스트(문맥) 하에서 완전한 의미를 가짐     
    같은 제품이라도 컨텍스트에 따라 의미가 다름

  => 이렇게 구분되는 `경계를 갖는 컨텍스트`를 DDD에선 bounded context라고 부름

<br/>

- `바운디드 컨텍스트` : 모델의 경계를 결정하며, `한 개의 bounded context는 논리적으로 한 개의 모델을 가짐`
  - 용어를 기준으로 구분함 
  - 실제로 사용자에게 기능을 제공하는 물리적 시스템으로 도메인 모델은 이 bounded context 안에서 도메인을 구현함   
  - 도메인 모델을 구분하는 경계가 되기 때문에 구현하는 하위 도메인에 알맞는 모델을 포함함

 <img width="478" alt="스크린샷 2023-10-09 오후 11 54 35" src="https://github.com/ttaehee/book-reviews/assets/103614357/ff59eb50-d670-4a4b-aa03-7596a52d9fff">

<br/>

### 장점
**bounded context 단위로 패키지를 나누고 개발했을 때의 장점**   

1. 시스템을 더 작은 단위로 한 눈에 알아봄
2. 각 도메인 모델의 책임이 작아져 코드 간결
3. bounded context 간 책임이 명확해서 유지보수 용이
4. 변경이 context 외부로 무분별하게 전파되지 않음
5. MSA 분리 용이

<br/>

### 구현

- bounded context는 `도메인 기능을 제공하는데 필요한 요소`를 모두 포함함
  - 도메인 모델 뿐 아니라, 표현 영역, 응용 서비스, 도메인, 인프라스트럭처, DB 테이블도 포함함    

<br/>

### 통합 방식
- 두 bounded context 간 `통합`이 필요한 경우
  - `REST API`로 `직접 통합`하는 방식
  - `메시지 시스템(메시지 큐)`으로 `간접 통합`하는 방식

<br/>

### 바운디드 컨텍스트 간 관계
- 두 bounded context간 관계 중 가장 흔한 관계
  - 한쪽에서 API 제공하고
  - 다른 한쪽에서는 그 API 를 호출하는 관계

  => 이 관계에서 `API를 사용하는 bounded context`는 `API를 제공하는 bounded context`에 `의존`하게 됨

<img width="460" alt="스크린샷 2023-10-10 오전 12 07 22" src="https://github.com/ttaehee/book-reviews/assets/103614357/f4b15cb9-fd90-4a6f-bea5-c5c764a7c1e4">

<br/>

- 서비스 공급자 : `상류 컴포넌트(upstream component)`
  - 상류 컴포넌트는 하류 컴포넌트가 사용 가능한 통신 프로토콜을 정의하고 이를 공개함     
- 서비스 고객 : `하류 컴포넌트(downstream component)`

<br/>

- `공개 호스트 서비스(open host service)` : 하류팀이 다수 존재하면 상류팀은 여러 하류팀의 요구사항을 수용할 수 있는 API를 만들고 이를 서비스 형태로 공개 -> 일관성 유지 가능   
  -  ex) 검색
    <img width="371" alt="스크린샷 2023-10-10 오전 12 16 01" src="https://github.com/ttaehee/book-reviews/assets/103614357/80e19f12-6463-4f6c-8e39-5c3be87a20ca">

    - 상류 컴포넌트 : 검색 시스템
    - 하류 컴포넌트 : 블로그, 카페, 게시판 등   

<br/>

- `공유 커널(shared kernel)` : 두 bounded context가 공유하는 모델
  - 모델을 두번 개발하는 중복감소
  - 한 팀에서 임의로 모델 변경을 할 수 없음

<br/>

## 컨텍스트 맵
- `컨텍스트 맵` : 바운디드 컨텍스트 간의 관계를 표현한 것    

<img width="445" alt="스크린샷 2023-10-10 오전 12 04 07" src="https://github.com/ttaehee/book-reviews/assets/103614357/792e2bdc-c157-4b12-97db-f2b3cf922e6e">

<br/>

## 💡 생각해볼 점
- 내가 이해한 9장
  - bounded context를 고려해서 모든 도메인에서 사용되는 하나의 모델이 아닌 각 도메인에 맞는 모델을 만들자

- [DDD에 대한 유튜브 영상](https://www.youtube.com/watch?v=n_9fBLl1gb4&t=701s)에서 본 댓글

  > 언급하셨다시피, DDD의 진정한 힘은 유비쿼터스언어와 바운디드 컨텍스트부터 시작합니다   
  유비쿼터스 언어를 반영해야 전술적 설계가 의미가 있는 셈이죠  
  OO 에 근간하지만 OO 원칙을 정면으로 위배하는 패턴도 몇 있어요    
  예를 들어, ID를 이용해서 애그리거트 간 디커플링을 시킨다든지, Domain Service는 행동을 객체에서 의도적으로 분리시키는 패턴이 OO와는 다른 개념입니다   
  Value 타입을 사용하는 것을 권장하는 등 저는 DDD의 전술적 설계가 순수 OO보다 더 적용하기 심플한 측면이 있다고 개인적으로 생각해요   

<br/>
