# Chapter 11 : CQRS

- [CQRS](#CQRS)
  - [장점](#장점)
  - [단점](#단점) 
- [💡 생각해볼 점](#-생각해볼-점) 

<br/>

## CQRS
- 상태 변경 범위와 상태 조회 범위가 정확하게 일치하지 않음      
  -> 단일 모델로 두 종류의 기능을 구현하면 모델이 불필요하게 복잡해짐    

  => `구현 복잡도를 낮추기` 위해, `상태 변경을 위한 모델`과 `조회를 위한 모델`을 분리 가능 

<br/>

- `CQRS(Command Query Responsibility Segregation)` : `상태를 변경하는 명령(Command)을 위한 모델`과 `상태를 제공하는 조회(Query)를 위한 모델`을 분리하는 패턴   

  - 조회 모델에는 응용 서비스가 존재하지 않음
  - 명령 모델과 조회 모델이 `서로 다른 데이터 저장소`를 사용할 수도 -> 데이터 동기화는 이벤트를 활용해 처리
    
    - ex) `명령 모델`에서 상태를 변경하면 `이벤트가 발생`하고 -> 그 이벤트를 `조회 모델`에 전달해서 `변경 내역을 반영`     
    
  => CQRS 는 복잡한 도메인에 적합

<br/>

### 장점
- 명령 모델을 구현할 때 도메인 자체에 집중 가능
- 로직이 분리됨
  - 명령 모델에서 조회 관련 로직이 사라져 복잡도 낮아짐
  - 조회 전용 모델을 사용하기 때문에 성능 향상을 위한 코드가 명령 모델에 영항을 주지 않음  
- 조회 성능 향상에 유리 + 조회 전용 저장소를 사용하면 처리량 증가 
- 조회 단위로 캐시 기술을 적용 가능   

<br/>

### 단점
- 구현 코드량 증가
- 도메인이 복잡하지 않거나 트래픽이 많지 않은 경우 얻을 이점 고려 필요
- 명령 모델과 조회 모델에서 서로 다른 구현 기술이나 저장소를 사용하기도 함   

<br/><br/>

## 💡 생각해볼 점

- 내가 이해한 11장
  - 도메인이 복잡하고 조회 속도를 높히기 위해 별도 처리를 하고 있다면, CQRS의 장단점을 따져보고 `명시적으로 명령 모델과조회 모델을 구분`하는걸 고려해보자

<br/>

- DDD와 OOP 차이는 무엇일까?
  - `OOP`는 상속이나 코드의 재활용 등 `공통된 데이터를 공유`하는 것을 중시 
  - `DDD`는 `도메인의 분리`를 중시   

<br/>

- 와 다 읽었다! 끝!
  다음주에 회사 코드에 적용해보는거 너무 궁금!        

<br/>
