## Chapter 11 : 뉴스 피드 시스템 설계

해당 챕터는 대규모 시스템에서 뉴스피드 기능을 효율적으로 구현하는 방법을 다룬다    
내용 자체는 구체적이지 않은데 따로 기록해두는 이유는 우리 서비스에도 적용할 수 있을것 같아서 (다른 챕터도 기록하면 좋겠지만 차차,,)       
로직이 좀 복잡한 부분이라 조회 속도가 느린데, 호출도 잦은 api 가 있다   
뉴스 피드처럼 생각하니 개선할 수 있을것 같다 (생각의 전환은 참 중요해)   
캐싱이나 no sql로 시도해봐야지     
   
<br/>

- [생각해볼 점](#-생각해볼-점)
- [1단계 :: 문제 정의](#1단계-문제-정의)
- [2단계 :: 개략적 설계](#2단계-개략적-설계)
- [3단계 :: 상세 설계](#3단계-상세-설계)
  - [피드 생성 방식](#피드-생성-방식)
  - [피드 전송 fanout (하이브리드 모델)](#피드-전송-fanout-하이브리드-모델)
  - [피드 읽기](#피드-읽기)
  - [캐시 구조](#캐시-구조)
- [4단계 :: 마무리](#4단계-마무리)

<br/>

### 💡 생각해볼 점  
- 실시간성과 데이터 일관성 사이의 trade-off?

   - 사실 사용자 경험 측면에서 실시간성은 중요한 요소이기 때문에 사용자가 로그인하거나 페이지를 새로고침할 때, 최신 게시물과 활동이 즉시 반영되는 것이 이상적이다       

     이를 위해 캐시와 비동기 처리가 필수적인데 경험상 분산환경에서 실시간성과 동시에 일관성까지 유지하는 것은 그만큼 어려웠다        

     예를 들어 게시물이 추가되거나 삭제되었을 때 모든 사용자에게 그 변화를 얼마나 빠르게 반영할 것인가       

   - CAP 이론에 따르면, 분산 시스템에서는 일관성(Consistency), 가용성(Availability), 분할 내성(Partition Tolerance) 중 두 가지 속성만을 우선시할 수 있다  

     즉, 시스템 설계에서 무엇을 우선할지 선택해야 하는 상황에 직면하게 되는것   

     - 실시간성을 중시하는 경우, 가용성과 분할 내성을 우선시하여 시스템이 항상 응답하도록 하고, 네트워크 장애 시에도 지속적으로 운영되도록 해야한다     

       이 경우, 일부 데이터가 지연되어 반영(= 일관성을 희생할 가능성)되더라도 시스템은 계속 운영된다        

     - 반대로 일관성을 우선시할 경우, 모든 데이터가 동기화된 후에만 사용자에게 제공되도록 하여 데이터 정확성을 보장할 수 있다

       그러나 네트워크 문제나 처리 속도가 느려지면 시스템이 제대로 작동하지 않거나 응답이 느려질 수 있다        

  - CAP 이론을 바탕으로, 시스템이 실시간성을 유지하면서도 어느 정도의 일관성을 유지하려면 우선순위를 잘 정해야 한다    
    그래야 사용자도 만족하고, 시스템도 안정적으로 운영될 것이다    

<br/>

- trade-off 의 실질적 영향과 해결 방안은?    

   - 시스템이 실시간으로 동작하면서도 어느 정도의 일관성을 유지하는 방법으로 자주 언급되는게 최종 일관성(Eventual Consistency)    

     일관성을 완전히 포기하지 않으면서도 실시간성을 높이는 방법으로 많이 채택한다         

     - 데이터가 일정 시간 후에는 결국 일관성을 갖도록 보장하는 방식       

       = 실시간성은 어느 정도 유지하되, 사용자가 모든 변화를 즉시 반영받는 대신 약간의 지연이 있을 수 있음을 허용        

   - 실시간성에 집중하면 사용자가 항상 최신 정보를 보지 못할 수 있는 상황이 발생할 수 있다          

     데이터 일관성 손실이 중요한 경우와 그렇지 않은 경우를 구분하고, 일관성 손실이 비즈니스에 큰 영향을 미치지 않는다면 일관성 요구를 낮추어도 될텐데     

     - 현재 일관성을 중요시해둔 탭이 있는데 많은 조인과 난감한 정렬 기준으로 인해 성능이 너무 떨어지기 때문에 점점 의문이 드는중 슬로우쿼리의 대표주자                 

       해당 탭의 데이터가 수정될만한 지점이 너무 많아서 캐시나 그래프 데이터베이스 사용이 꺼려지기도 하는데 트레이드오프를 잘 따져보아야겠다         

<br/>    

- 확장성?    

  - 피드 시스템은 수백만 명의 사용자와 그들의 친구 관계, 활동 등을 처리해야 하므로 데이터베이스 샤딩이나 캐시 파티셔닝이 중요한 요소     

     우리 서비스도 마찬가지인데 지역과 관련이 있어서 지역별로 분산 서버를 사용하여 사용자 경험을 최적화할 방법을 생각해볼 수 있겠다   

     그냥 막연하게 해본 생각이고 지역별로 분산서버를 사용할 정도의 크기는 아직 아니라고 생각한다     

<br/>


### 1단계 :: 문제 정의
- 뉴스피드 시스템의 목표 : 사용자가 관심을 가질 만한 정보를 실시간으로 빠르고 정확하게 제공하는 것    

- 주요 요구사항 : 사용자가 보는 피드의 개인화, 실시간 업데이트, 성능, 확장성, 일관성 등 포함

<br/>

- 질문 예시
  - 모바일 앱을 위한 시스템인가요? 아니면 웹? 둘 다 지원해야 합니까?
  - 중요한 기능으로는 어떤 것이 있을까요?
  - 뉴스 피드에는 어떤 순서로 스토리가 표시되어야 하나요? 최신순 인가요? 아니면 토픽 점수(topic score) 같은 다른 기준이 있습니까?
  - 한 명의 사용자는 최대 몇 명의 친구를 가질 수 있습니까?
  - 트래픽 규모는 어느 정도입니까?
  - 피드에 이미지나 비디오 스토리도 올라올 수 있습니까?    

<br/>

### 2단계 :: 개략적 설계
두 가지 부분으로 나누어 진행    
- 피드 발행(feed publishing) : 사용자가 스토리를 포스팅하면 해당 데이터를 캐시와 데이터베이스에 기록
  
  ![스크린샷 2024-10-14 오후 11 22 12](https://github.com/user-attachments/assets/e1712f06-1667-4304-a84a-2315c54e6283)
  
  - 포스팅 저장 서비스 (post service): 새 포스팅을 데이터베이스와 캐시에 저장     

  - 포스팅 전송 서비스 (fanout service): 새 포스팅을 친구의 피드에 push -> 피드 데이터는 캐시에 보관하여 빠르게 읽어갈 수 있도록 함     

<br/>
  
- 피드 생성(news feed building) : 피드는 모든 친구의 포스팅을 시간 흐름 역순으로 모아서 만든다고 가정
  
  ![스크린샷 2024-10-14 오후 11 21 36](https://github.com/user-attachments/assets/ba7f9be5-7f3e-46cf-a399-45683a505ec5)

  - 피드 서비스 (news feed service): 캐시에서 피드를 가져오는 서비스    

  - 피드 캐시 (news feed cache): 피드를 렌더링할 때 필요한 피드 ID를 보관     

<br/>

### 3단계 :: 상세 설계     

포스팅 전송 서비스 (fanout service)
- 포스팅 전송, 즉 fanout은 어떤 사용자의 새 포스팅을 그 사용자와 친구 관계에 있는 모든 사용자에게 전달하는 과정    

<br/>

fanout에는 두 가지 model이 있는데     

- 하나는 쓰기 시점에 팬아웃(fanout-on-write)하는 model (push model 이라고도 함)

- 다른 하나는 읽기 시점에 팬아웃(fanout-on-read)하는 model (pull model 이라고도 함)

<br/>

#### 피드 생성 방식
- 1) Push 모델 : 사용자에게 필요한 피드를 미리 생성하여 저장해두고, 사용자가 요청하면 이미 생성된 피드를 바로 제공   

  - 장점

    - 빠른 응답

    - 비활성화된 사용자에게 유리 : 서비스를 자주 사용하지 않는 사용자의 경우에는 이 모델이 효율적

    - Hotkey 문제 완화 : 데이터를 친구 각각에 미리 푸시하는 작업이 필요 없으므로 hotkey 문제를 피할 수 있음

  - 단점

    - 실시간성 저하 : 피드가 미리 생성된 것이기 때문에, 새로운 업데이트가 발생하면 사용자가 즉시 최신 정보를 볼 수 없을수도      

    - 자원 낭비 : 자주 사용하지 않는 사용자의 피드를 미리 생성해두면, 그 데이터가 필요 없을 경우에도 리소스가 낭비될 수 있음    
 
<br/>

- 2) Pull 모델 : 사용자가 요청할 때마다 피드를 실시간으로 생성

   - 장점
  
    - 실시간성 보장 : 피드 생성 시점에 필요한 모든 데이터를 수집해 사용자에게 제공 = 피드가 실시간으로 갱신 + 친구 목록에 있는 사용자에게 즉시 전송
  
    - 효율적인 자원 사용 : 자주 로그인하지 않는 사용자의 피드를 미리 생성할 필요가 없어서 자원 낭비 감소    

   - 단점 

     - 성능 저하 : 사용자가 요청할 때마다 실시간으로 피드를 생성하기 때문에 친구가 많거나 대량의 데이터를 처리해야 하는 경우, 피드를 생성하는 데 시간이 오래 걸릴 수 있음   

     - hotkey 문제 : 특정 사용자에게 요청이 몰리는 상황
      - 특정 사용자의 피드를 갱신할 때(새 포스팅이 기록되는 순간에 뉴스 피드가 이미 갱신되므로(pre-computed)), 그 사용자와 연결된 많은 사용자들의 피드를 동시에 처리(사용자의 경우 친구 목록을 가져오고 그 목록에 있는 사용자 모두의 피드를 갱신)해야 하므로 자원 소모가 많아져 hotkey 문제 발생 가능

<br/>


- 3) 하이브리드 모델 : Pull과 Push 모델을 결합한 방식

  - Push 모델은 자원이 적게 드는 상황에서 미리 피드를 생성하고 제공하여 빠른 응답을 보장      

  - Pull 모델은 자원이 많이 필요한 경우 사용자가 필요할 때만 피드를 가져가도록 하여 시스템 자원의 낭비를 줄임

   - 본 설계안은 위의 두 가지 방법을 결합하여 사용 -> 실시간성과 성능을 균형있게 유지 가능    

    - 팔로워가 아주 많은 사용자 - 실시간성 : 이들의 피드를 매번 푸시하면 성능 부담이 크기 때문에 팔로워들이 해당 사용자의 포스팅을 필요할 때 가져가도록 하는 pull model을 사용

    - 일반 사용자 - 성능 최적화 : 상대적으로 작은 사용자 그룹에게는 push model 사용해 미리 피드를 생성해 두어 리소스를 아끼고, 빠른 응답을 보장  

    - hotkey 문제 해결 : 안정적인 해시(Consistent Hashing) 기법을 적용하여 요청과 데이터이 여러 서버에 분산되기 때문에 서버 과부하가 줄어듬   

<br/>

#### 피드 전송 fanout (하이브리드 모델)

![스크린샷 2024-10-14 오후 11 31 46](https://github.com/user-attachments/assets/9ba52c12-ae48-4c5c-a7bc-cc75a8a5268a)

1. 그래프 데이터베이스에서 친구 ID 목록을 가져옴    

    그래프 데이터베이스는 친구 관계나 친구 추천을 관리하기 적합    

    (관련 논문 : TAO: facebook's distributed date store for the social graph)

<br/>

2. 사용자 정보 캐시에서 친구들의 정보를 가져옴   
 
   그런 후에 사용자 설정에 따라 친구 가운데 일부를 걸러냄    
 
   (ex) 내 글에 대해서 mute 처리한 친구)   

<br/>

3. 친구 목록과 새 스토리의 포스팅 ID를 message queue에 넣음

<br/>

4. 포스팅 전송(fanout) 작업 서버가 message queue에서 데이터를 꺼내어 피드 데이터를 피드 캐시에 넣음     

   피드 캐시는 <포스팅 ID, 사용자 ID>의 순서쌍을 보관하는 mapping table 느낌          

   새로운 포스팅이 만들어질 때마다 이 캐시에 레코드들이 추가될 것         

<br/>

메모리 절약을 위해 최소한의 데이터를 저장함    

사용자가 수천 개의 스토리를 전부 훑어보는 일이 벌어질 확률은 지극히 낮기 때문에 -> 메모리 크기를 적정 수준으로 유지하기 위해서 이 캐시의 크기에 제한을 두며, 해당 값은 조정이 가능하도록 함             

대부분의 사용자가 보려 하는 것은 최신 포스팅 -> 따라서 cache miss가 일어날 확률은 낮음   

<br/>

#### 피드 읽기   

![스크린샷 2024-10-14 오후 11 58 30](https://github.com/user-attachments/assets/95e1c160-4127-402d-8515-4a8f31d3f183)

1. 사용자가 피드 조회 요청  

2. 로드밸런서가 요청을 웹 서버 가운데 하나로 보냄

3. 웹 서버는 피드를 가져오기 위해 피드 서비스 호출    

4. 피드 서비스는 피드 캐시에서 포스팅 ID 목록을 가져옴

5. 피드에 표시할 사용자 이름, 사용자 사진, 포스팅 콘텐츠, 이미지 등을 사용자 캐시와 포스팅 캐시에서 가져와 완전한 피드 조합

6. 생성된 피드를 JSON 형태로 클라이언트에게 응답 -> 클라이언트는 해당 피드를 렌더링     

<br/>

#### 캐시 구조

![스크린샷 2024-10-14 오후 11 59 06](https://github.com/user-attachments/assets/74032a2a-83de-48a6-bd5f-2f8a1e9d1cf5)

- 뉴스 피드: 뉴스 피드의 ID를 보관
  
- 콘텐츠: 포스팅 데이터를 보관 (인기 콘텐츠는 따로 보관)

- 소셜 그래프: 사용자 간 관계 정보를 보관 

- 행동(action): 포스팅에 대한 사용자의 행위에 관한 정보를 보관 (ex) 좋아요, 댓글 등)

- 횟수(counter): 좋아요 횟수, 응답 수, 팔로워 수, 팔로잉 수 등의 정보를 보관     

<br/>

### 4단계 :: 마무리
회사마다 제약이나 요구 조건이 있기 때문에 시스템을 설계할 때는 그런 점을 고려해야함      
설계를 진행하고 기술을 선택할 때는 그 배경에 어떤 trade-off 들이 있었는지 잘 이해하고 설명할 수 있어야 함   

<br/>

- 추가적으로 다루면 좋은 것들
  - 데이터베이스 규모 확장
  - 수직적 규모 확장 vs 수평적 규모 확장
  - SQL vs NoSQL
  - master-slave에 대한 읽기 연산
  - 일관성 모델
  - 데이터베이스 샤딩
  - 가능한 많은 데이터를 캐시할 방법
  - 메시지 큐를 사용하여 컴포넌트 사이의 결합도 낮추기

<br/>
