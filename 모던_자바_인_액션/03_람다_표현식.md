# Chapter 3 : 람다 표현식  

- [람다란 무엇인가?](#람다란-무엇인가)
- [어디에, 어떻게 람다를 사용할까?](#어디에-어떻게-람다를-사용할까)
- [람다 활용 : 실행 어라운드 패턴](#람다-활용--실행-어라운드-패턴)
- [함수형 인터페이스 사용](#함수형-인터페이스-사용)
  - [Predicate](#Predicate)
  - [Consumer](#Consumer)
  - [Function](#Function)
  - [Supplier](#Supplier)
- [메서드 참조](#메서드-참조)
- [💡 생각해볼 점](#-생각해볼-점) 

<br/>

익명 클래스를 통해 다양한 동작을 구현할 수 있지만, 코드가 깔끔하지 않다   
깔끔하지 않으면 실무에 적용하기 꺼려진다        
이번엔 더 깔끔한 코드로 동작을 구현하고 전달하는 자바 8의 람다 표현식을 알아보자    

<br/>

## 람다란 무엇인가?
- `람다 표현식` : 메서드로 전달할 수 있는 `익명 함수를 단순화`한 것
- 람다의 특징
  - 익명 : 보통의 메서드와 달리 이름이 없음    
  - 함수 : 람다는 메서드처럼 특정 클래스에 종속되지 않으므로 함수라고 부름    
    (하지만 메서드처럼 파라미터 리스트, 바디, 반환 형식, 가능한 예외 리스트를 포함)   
  - 전달 : 람다 표현식을 메서드 인수로 전달하거나 변수로 저장 가능   
  - 간결성 : 익명 클래스처럼 많은 코드를 구현할 필요가 없음  

<br/>

- ex)

```java
Comparator<Apple> byWeight = new Comparator<Apple> () {
    public int compare(Apple a1, Apple a2) {
        return a1.getWeight().compareTo(a2.getWeight());
    }
};
```

<br/>

=> 람다 적용하면
  - 동작 파라미터를 이용할 때 동작 파라미터 형식의 코드를 더 쉽게 구현할 수 있음      
    (기술적으로 8 이전의 자바로 할 수 없었던 일을 제공하는 것이 아님)
  - 결과적으로 코드가 유연해지고 간결해짐   
  
```java
Comparator<Apple> byWeight = (Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight());
```

<br/><br/>

## 어디에, 어떻게 람다를 사용할까?
- 어디에서 람다를 사용할 수 있을까?
  - => 함수형 인터페이스라는 문맥에서 사용
- 함수형 인터페이스는 뭔데?
  - => 오직 `하나의 추상 메서드`를 가지고 있는 인터페이스
 
```java
public interface Predicate<T> {
    boolean test (T t);
}
public interface Comparator<T> {
    int compare (T o1, T o2);
}
public interface Runnable {
    void run();
}
```

```java
//람다 사용 
Runable r1 = () -> System.out.println("hello world"); 

//익명 클래스 사용
Runable r2 = new Runnable() { 
	public void run() { 
    	System.out.println("hello world"); 
     }
};
```

람다 표현식으로 함수형 인터페이스의 추상 메서드 구현을 직접 전달 할 수 있음      
=> `전체 표현식`을 `함수형 인터페이스의 인스턴스`로 취급할 수 있음(기술적으로 따지면 함수형 인터페이스를 구현한 클래스의 인스턴스)  

<br/>

- 함수 디스크립터 : 람다 표현식의 시그니처를 서술하는 메서드(함수형 인터페이스의 추상 메서드 시그니처)
  - ex) `() -> void` 표기는 파라미터 리스트가 없으며 void를 반환하는 함수를 의미  

<br/><br/>

## 람다 활용 : 실행 어라운드 패턴

- 실행 어라운드 패턴 : 실제 자원을 처리하는 코드를 설정과 정리 두 과정이 둘러싸는 형태  
  - 자원 처리에 사용하는 순환 패턴은 자원을 열고, 처리한 다음에, 자원을 닫는 순서로 이루어짐 (`설정-작업-정리 형식`의 코드)

<br/><br/>

## 함수형 인터페이스 사용     
Java API는 `Comparable, Runnable, Callable` 등의 다양한 함수형 인터페이스를 포함하고 있음   

<br/>

### Predicate
`(T) -> boolean`의 시그니처    
- Predicate<T> 인터페이스는 test라는 추상 메서드를 정의
- test는 제네릭 형식 T의 객체를 인수로 받아 불리언을 반환

<br/>

### Consumer     
`(T) -> ()`의 시그니처   
- Consumer<T> 인터페이스는 accept라는 추상 메서드를 정의
- 제네릭 형식 T의 객체를 인수로 받아 어떤 동작을 수행하고 싶을때 사용

<br/>

### Function
`(T) -> (R)`의 시그니처   
- Function<T, R> 인터페이스는 제네릭 형식 T를 인수로 받아서 제네릭 형식 R 객체를 반환하는 추상 메서드 apply를 정의
- 입력을 출력으로 매핑하는 람다를 정의할때 활용

<br/>

### Supplier    
`() -> (T)`의 시그니처

<br/><br/>

## 지역 변수 사용    

람다 표현식에서는 익명 함수가 하는 것처럼 `자유 변수(파라미터로 넘겨진 변수가 아닌 외부에서 정의된 변수) 활용` 가능(람다 캡쳐링이라 부름)    

- 이 때의 제약 조건
  - 람다는 인스턴스 변수와 정적 변수를 자유롭게 캡쳐(자신의 바디에서 참조할 수 있도록) 가능    
    - 그러려면 지역변수는 명시적으로 `final` 선언이 되어있거나, 실질적으로 final처럼 사용해야 함    
      즉, `람다 표현식은 한 번만 할당할 수 있는 지역 변수만 캡쳐 가능`    
      (인스턴스 변수 캡처는 final 지역변수 this를 캡쳐하는 것과 마찬가지) 

<br/>

- 왜 지역 변수에 이런 제약이 필요할까?    
  - 우선 메모리에 저장되는 위치가 다름 : `인스턴스 변수(힙 영역)`, `지역 변수(스택 영역)`       
    (람다에서 지역 변수에 바로 접근할 수 있다는 가정하에) 변수를 할당한 스레드가 사라져서 `변수 할당이 해제`되었는데도, `람다가 실행하는 스레드`에서는 `해당 변수에 접근하려` 할 수 있음        
    => 자바 구현에서는 원래 변수에 접근 허용이 아닌 자유 `지역 변수의 복사본을 제공`함     
    => 따라서 `복사본의 값이 바뀌지 않아야` 함 => 지역 변수에는 한 번만 값을 할당해야 한다는 제약 필요   

<br/><br/>

## 메서드 참조
특정 메서드만을 호출하는 `람다의 축약형`     

```java
inventory.sort((Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight()));

inventory.sort(Comparing(Apple::getWeight));
```

<br/><br/>

## 💡 생각해볼 점     
- 메서드 참조를 사용하면 좋은점은?   
  - 메서드를 `어떻게 호출`해야 하는지 설명을 참조하기보다는 `메서드명을 직접 참조`하는 것이 편리하다    
    명시적으로 메서드를 참조함으로써 `가독성`을 높일 수 있다    
  - 메서드 참조를 이용하면 기존의 메서드 구현을 재사용하고 직접 전달할 수 있다   

<br/>

- 람다 표현식 전체가 함수형 인터페이스의 인스턴스로 취급된다   

<br/>
