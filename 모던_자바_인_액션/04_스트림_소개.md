# Chapter 4 : 스트림 소개   

- [스트림이란 무엇인가?](#스트림이란-무엇인가)
- [스트림과 컬렉션](#스트림과-컬렉션)
  - [차이점](#차이점)
    - [딱 한번만 탐색할 수 있다](#딱-한번만-탐색할-수-있다)
    - [외부 반복과 내부 반복](#외부-반복과-내부-반복)
- [스트림 연산](#스트림-연산)
  - [중간 연산](#중간-연산)
  - [최종 연산](#최종-연산)
- [💡 정리 및 생각해볼 점](#-정리-및-생각해볼-점) 

<br/>

SQL을 사용하는 것처럼 `어떻게 구현해야하는지 명시할 필요 없이` `컬렉션`을 다루고 싶으면,   
`멀티코어의 특징`을 살려 컬렉션을 다룰 때 성능의 이점을 누리고 싶으면,   

=> 스트림!

<br/>

## 스트림이란 무엇인가?
- `데이터 처리 연산을 지원`하도록 `소스에서 추출`된 `연속된 요소`   
  - 참고) 이게 무슨말이야,,   
    - `연속된 요소?`  
      - collection과 마찬가지로 stream은 특정 요소 형식으로 이루어진 `연속된 값 집합의 인터페이스`를 제공   
      - collection은 자료구조 -> 컬렉션에서는 시간과 공간의 복잡성과 관련된 `요소 저장 및 접근 연산`이 주를 이룸     
      - 반면 stream은 filter, sorted, map 처럼 `표현 계산식`이 주를 이룸    
      => 즉, `컬렉션의 주제는 데이터이고 스트림의 주제는 계산`!   
    - `소스?`
      - 스트림은 `collection, 배열, IO 자원` 등의 `데이터 제공 소스`로부터 `데이터를 소비`함
      - 정렬된 collection으로 stream을 생성하면 정렬이 그대로 유지됨       
    - `데이터 처리 연산?`
      - 스트림은 `함수형 프로그래밍 언어에서 일반적으로 지원하는 연산`과 `데이터베이스와 비슷한 연산`을 지원함
        - ex) filter, map, reduce, find, match 등으로 데이터 조작 가능
        - ex) 스트림 연산은 순차적 또는 병렬로 실행 가능

<br/>

- 스트림을 이용하면 
  - 선언형(데이터를 임시 구현 코드 대신 질의료 표현)으로 collection data 처리 가능   
  - multi-thread 코드를 구현하지 않아도 데이터를 투명하게 병렬로 처리 가능 (7장에서 설명)

<br/>

- 가비지 변수, 즉 중간 컨테이너 역할을 하는 중간 변수를 사용하지 않고도 컬렉션 데이터 처리 가능

```java
List<String> lowCaloricDishesName = menu.stream()
    .filter(d -> d.getCalories() < 400)
    .sorted(comparing(Dish::getCalories))
    .map(Dish::getName)
    .collect(toList());
```

=> `filter, sorted, map, collect` 같은 여러 빌딩 블록 연산을 연결      
-> 복잡한 `데이터 처리 파이프라인` 만들기 가능   
-> `고수준 빌딩 블록`으로 이루어져 있어     
-> 특정 스레딩 모델에 제한되지 않고 자유롭게 어떤 상황에서든 사용 가능

=> 스레드, 락 걱정 없이 데이터 병렬 처리 가능

<br>

### 스트림 API 특징 정리
- `선언형` : 더 간결하고 가독성이 좋아짐
- `조립가능` : 유연성이 좋아짐
- `병렬화` : 성능이 좋아짐

<br/><br/>

## 스트림과 컬렉션    

- `공통점 : 모두 `연속된 요소 형식의 값을 저장`하는 자료구조의 인터페이스를 제공함
  - 여기서 `연속된`이라는 표현 = 순서와 상관없이 아무 값에나 접근하는 것이 아니라 순차적으로 값에 접근한다는 것 의미
- `가장 큰 차이점` : 데이터를 `언제 계산`하느냐
  - `컬렉션`은 현재 자료구조가 포함하는 모든 값을 메모리에 저장하는 자료구조    
    -> 컬렉션의 모든 요소는 컬렉션에 추가하기 전에 계산되어야 함 like DVD 
  - `스트림`은 이론적으로 요청할 때만 요소를 계산 하는 고정된 자료구조(스트림에 요소 추가/제거 불가)        
    -> 요청할 때만 요소를 계산하기 때문에 사용자가 요청하는 값만 스트림에서 추출함 like 스트리밍  

  => 즉, 스트림은 게으르게 만들어지는 컬렉션과 같음

<br/>

### 차이점

#### 딱 한번만 탐색할 수 있다

- 반복자와 마찬가지로 스트림도 한 번만 탐색 가능 = 즉, `탐색된 스트림 요소는 소비`됨     

  -> 스트림에서 데이터를 `다시 탐색`하려면 초기 데이터 소스에서 `새로 스트림을 만들어야` 함   
    = 반복해서 데이터를 읽으려면, 그 데이터 소스가 반복 가능해야 함 (I/O 채널은 반복이 안 될 수 있음)
  
    ex) 만약 데이터 소스가 I/O 채널이라면, 소스를 반복사용 할 수 없어 새로운 스트림을 만들 수 없음    

<br/>

#### 외부 반복과 내부 반복
- `컬렉션`은 사용자가 `직접 요소를 반복`해야 함(EX: for-each) -> `외부 반복`  
- `스트림`은 `알아서` 반복을 수행하고 결과 스트림값을 어딘가에 저장함 -> `내부 반복`  

<br/>

- 내부 반복을 이용하면 작업을 투명하게 병렬로 처리 or 더 최적화된 순서로 처리 가능
- 내부 반복을 사용하지 않으면 synchronized 등을 사용해서 직접 병렬성을 보장해야 함  

<br/><br/>

## 스트림 연산   
- 연결할 수 있는 스트림 연산 : 중간 연산   
- 스트림을 닫는 연산 : 최종 연산   

<br/>

### 중간 연산
- 중간 연산(ex) filter, sorted 같은)은 `다른 스트림을 반환`함    
  -> 따라서 여러 중간 연산을 연결해서 질의를 만들 수 있음    

- 중간 연산의 중요한 특징은 단말 연산을 스트림 파이프라인에 실행하기 전까지는 아무 연산도 수행하지 않음 (= lazy 하다)     
  `중간 연산을 합친 다음에` 합쳐진 중간 연산을 `최종 연산으로 한번에 처리`    

==> 중간 연산만으로는 결과를 생성할 수 없음!   

|연산|반환 형식|연산의 파라미터|함수 디스크립터|
|------|---|---|---|
|filter|Stream<T>|Predicate<T>|T -> boolean|
|map|Stream<T>|Function<T, R>|T -> R|
|limit|Stream<T>| | |
|sorted|Stream<T>|Comparator<T, R>|(T, T) -> int|
|distinct|Stream<T>| | |

<br/> 

### 최종 연산
- 최종 연산은 스트림 파이프라인에서 `결과를 도출`함    
  -> 보통 List, Integer, void 등 `스트림 외의 결과가 반환`됨    

|연산|반환 형식|목적|
|------|---|---|
|forEach|void|스트림의 각 요소를 소비하면서 람다를 적용함|
|count|Long|스트림의 요소 개수 반환|
|collect||스트림을 리듀해서 리스트, 맵, 정수 형식의 컬렉션을 만듬 (6장 참고)|

<br/> 

==> 스트림 이용 과정     
1. 질의를 수행할 `데이터 소스` (ex) collection 같은)   
2. stream pipeline을 구성할 `중간 연산 연결`   
3. stream pipeline을 실행하고 결과를 만들 `최종 연산`   

<br/><br/>

## 💡 정리 및 생각해볼 점

- 스트림은 `소스에서 추출된 연속 요소`로, `데이터 처리 연산`을 지원한다   
- 스트림은 `내부 반복`을 지원한다
  - 내부 반복은 filter, map, sorted 등의 연산으로 반복을 추상화한다   
- 스트림에는 `중간 연산과 최종 연산`이 있다   
  - 중간 연산을 이용해서 파이프라인을 구성할 수 있지만 어떤 결과도 생성할 수 없다   
  - 스트림이 아닌 결과를 반환하는 연산을 최종 연산이라고 한다   
- 스트림의 요소는 요청할 때 `lazy하게 계산`되며 최종 연산에서 `한번에 처리`된다

<br/>

- 스트림의 `단점`은?
  - `디버깅이 어려움` 
    - 에러 발생 시, 일반 코드의 경우 값이 잘못되기 직전에 디버그 걸어놓으면 확인 가능
    - 하지만 스트림은 `한번에 수행`되기 때문에 `처음부터 전부 확인 필요`
  - `재사용 불가능`
    - 스트림은 한번 쓰면 close되기 때문에 계속 사용은 불가

<br/>
