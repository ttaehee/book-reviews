# Chapter 1 : 자바 8, 9, 10, 11 무슨 일이 일어나고 있는가?     

- [자바 8](#자바-8)
  - [1. Stream 처리](#1-Stream-처리)  
  - [2. 동작 파라미터화로 메서드에 코드 전달하기](#2-동작-파라미터화로-메서드에-코드-전달하기)
  - [3. 병렬성과 공유 가변 데이터](#3-병렬성과-공유-가변-데이터)
  - [4. 자바 함수](#4-자바-함수)
    - [Method reference](#Method-reference) 
    - [Lamda(익명함수)](#Lamda-익명함수-)  
- [💡 생각해볼 점](#-생각해볼-점)  


<br/>
   
## 자바 8    
- 자바 8 등장 전, 멀티코어 활용하려면 thread 사용하는 것이 좋다는 의견 있었음   
  - but, thread 사용하면 관리 어려움   

<br/> 

- 자바 역사 중 `자바 8에서 가장 큰 변화` <- 멀티코어 CPU의 대중화와 하드웨어적인 변화 영향     

  - 두가지 요구사항 기반 
    - 간결한 코드
    - 멀티코어 프로세스의 쉬운 활용  
    
  - 제공하는 새로운 기술
    - `Stream API`
      - 병렬연산 지원 -> synchronized 사용 안해도 됨 
      - Stream API로 인해 아래 두가지 기능이 존재할 수 있음 
    - `method에 code를 전달하는 방법` (-> 동작 파라미터화, 함수형 프로그래밍)
      - 메서드 참조
      - 람다 
    - `interface의 default method`


=> 객체지향 프로그래밍, 함수형 프로그래밍의 장점을 누릴 수 있게됨   

<br/><br/>

### 1. Stream 처리   
- stream : 한번에 한개씩 만들어지는 연속적인 데이터 항목들의 모임    
- 자바 8에서 `java.util.stream` package에 Stream API 추가
  - pipeline인을 만드는데 필요한 많은 메서드를 제공 


- `Stream API`의 핵심
  - `한 번에 한 항목`을 처리하던걸    
    -> 자바 8에서는 우리가 하려는 작업을 고수준으로 추상화해서 `일련의 스트림`으로 만들어 처리할 수 있음
  - stream pipeline을 이용해서 입력 부분을 `여러 CPU core에` 쉽게 할당할 수 있음   
  - thread(복잡한 작업) 사용하지 않으면서 `병렬성` 얻을 수 있음     

<br/><br/>

### 2. 동작 파라미터화로 메서드에 코드 전달하기   
- 코드 일부를 API로 전달하는 기능     

  = `method`를 `다른 method의 인수`로 넘겨주는 개념     
  
  = `동작 파라미터화`  

- Stream API는 `연산의 동작을 parameter화`할 수 있는 code를 전달한다는 사상에 기초   

<br/><br/>

 
### 3. 병렬성과 공유 가변 데이터

- 다른 코드와 동시에 실행하더라도 안전하게 실행하려면    
  -> `공유된 가변 데이터(shared mutable data)`에 접근하지 않아야 함      
  
  = 순수 함수, 부작용 없는 함수, 상태 없는 함수
  
- synchronized를 이용해서 공유된 가변 데이터를 보호하는 규칙 만들 수 있음    
    
  -> 에러 자주 일으킴, 비용 비싼 키워드  
  
  -> `자바 8 Stream` 이용하면 기존의 Java Thread API보다 `쉽게 병렬성 활용` 가능     

<br/><br/>

### 4. 자바 함수    
Stream과 연계될 수 있도록 만든 함수    

- 자바 8에서는 `함수`를 `새로운 값의 형식`으로 추가했음   

  = 함수를 값처럼 취급

<br/>
 
- `일급 자바 시민` : 전달할 수 있는 구조체
- `이급 자바 시민` : 전달할 수 없는 구조체
  - 그 자체로 값이 될 수 없는
  - method, class

<br/>

- `method를 일급값`으로 사용하면 -> `런타임에 method 전달` 가능 -> 프로그래밍에 유용하게 활용 가능   
  - 자바 8에서 이급 시민을 일급 시민으로 바꿀 수 있는 기능 추가   
  
    = `method or 함수를 값으로 취급`할 수 있는 기능
    
    - `method reference`
    - `lamda`

<br/><br/>

#### Method reference    
method를 일급값으로 취급    

```java
File[] hiddenFiles = new File(".").listFiles(new FileFilter() {
	public boolean accept(File file) {
		return file.isHidden();
	}
});
```

- File class에 이미 isHidden이라는 method가 있는데 왜 굳이 FileFilter로 isHidden을 감싼 다음에 FileFilter를 인스턴스화해야 할까  

<br/>

```java
File[] hiddenFiles = new File(".").listFiles(File::isHidden);
```

- 기존에 `객체 참조`(new로 객체 참조를 생성함)를 이용해서 객체를 주고받았던 것처럼       
  자바 8에서는 `File::isHidden`을 이용해서 메서드 참조를 만들어 전달 가능   
  
  -`메서드 참조 ::` : 이 method를 값으로 사용하라는 의미



<br/><br/>

#### Lamda (익명함수)    
함수(람다 포함)도 값으로 취급    

- ex) `(int x) → x + 1` : `x라는 인수로 호출하면 x + 1을 반환`하는 동작 수행하도록 코드 구현 가능     

<br/>
  
- 람다 문법 형식으로 구현된 프로그램     
  
  = 함수를 일급값으로 넘겨주는 프로그램 구현
  
  = 함수형 프로그래밍 

<br/><br/>


## 💡 생각해볼 점   

- Java는 잘 알려져있다 싶이 객체지향 언어이지, 순수한 함수형 언어는 아니다    
  그러나, 자바 8에서 여러 기능이 추가됨으로써 함수형 언어의 특성을 접목할 수 있게 되었다     
  저자의 말처럼 세상의 변화와 요구에 발 맞추어 가는 것은 올바른 방향이라고 생각한다   

<br/> 

- 함수형 프로그래밍의 장점은 무엇인가
  - 불변 : 데이터를 함수 밖에서 변형하지 않음   
  - 순수 함수 : 입력 파라미터에만 의존하며, 부수 효과를 일으키지 않는 함수가 됨  
    - 정해진 입력 값을 주면 정해진 반환 값을 주기만 할 뿐, 부수 효과가 발생하지 않는 단순한 구조를 가지고 있음   
  - 함수 단위의 코드 재사용 가능  
  
<br/> 

- 함수형 프로그래밍의 단점은 무엇인가   
  - 함수형 프로그래밍의 개념 이해가 쉽지 않음   
  - 함수들 파악 필요  
  - 함수가 많아질 수록, 함수를 조합하기 복잡 -> 꾸준한 리팩토링 필요할 수도 있음   
  
<br/> 
