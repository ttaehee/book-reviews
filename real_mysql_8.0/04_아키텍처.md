# Chapter 4 : 아키텍처   

- [MySQL 전체 구조](#MySQL-전체-구조)
  - [MySQL 엔진 & 스토리지 엔진](#MySQL-엔진-스토리지-엔진)
- [MySQL 스레딩 구조](#MySQL-스레딩-구조)
  - [MySQL(InnoDB)이 스레드를 포그라운드, 백그라운드로 나눈 이유?](#MySQL(InnoDB)이-스레드를-포그라운드-백그라운드로-나눈-이유?)
- [메모리 할당 및 사용 구조](#메모리-할당-및-사용-구조)
- [MySQL의 플러그인과 컴포넌트](#MySQL의-플러그인과-컴포넌트)
- [MySQL 쿼리 실행 구조](#MySQL-쿼리-실행-구조)
- [트랜잭션 지원 메타데이터](#트랜잭션-지원-메타데이터)
- [InnoDB 스토리지 엔진 아키텍처](#InnoDB-스토리지-엔진-아키텍처)
  - [Primary 키에 의한 클러스터링](#Primary-키에-의한-클러스터링)
  - [외래키 지원](#외래키-지원)
  - [MVCC(Multi Version Concurrency Control)](#MVCC-Multi-Version-Concurrency-Control)
  - [자동 데드락 감지](#자동-데드락-감지)
  - [자동화된 장애 복구](#자동화된-장애-복구)
  - [InnoDB의 버퍼풀(for 데이터 캐시, 쓰기 버퍼링)](#InnoDB의-버퍼풀-for-데이터-캐시-쓰기-버퍼링)
- [💡 생각해볼 점](#-생각해볼-점) 

<br/>

## MySQL 전체 구조
### MySQL 엔진 & 스토리지 엔진
- MySQL 엔진 : 사람의 머리 역할을 담당
  - SQL을 분석하거나 최적화하는 등의 DBMS의 두뇌와 같은 역할
- 스토리지 엔진 : 손과 발의 역할 담당
  - 실제 데이터를 디스크에 저장하고 읽어옴

<br/><br/>

## MySQL 스레딩 구조
MySQL 서버는 프로세스 기반이 아니라 스레드 기반으로 작동함    
크게 포그라운드 스레드와 백그라운드 스레드로 구분 가능  

<br/>

InnoDB 테이블의 경우에는 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리하고, 나머지 버퍼로부터 디스크까지 기록하는 작업은 백그라운드 스레드가 처리함   

### 포그라운드 스레드(클라이언트 스레드, 사용자 스레드)   
- MySQL 서버에 접속한 클라이언트의 개수만큼 존재
  - 사용자가 작업을 마치고 connection을 종료하면 해당 connection을 담당하는 thread는 다시 thread cache로 돌아가고, 항상 일정 개수의 thread가 유지됨         
- 실제 사용자의 요청을 처리
- 데이터를 읽는 작업 처리

### 백그라운드 스레드   
- 개수는 MySQL 서버의 설정에 따라 가변적으로 달라짐
- 디스크에 데이터를 직접 기록하는 작업 처리   
  - 현재 로그나 버퍼풀에 있는 데이터를 디스크에 기록
- 데이터를 버퍼로 읽어오기
- 인서트 버퍼 병합
- 잠금이나 데드락 모니터링

<br/>

### MySQL(InnoDB)이 스레드를 포그라운드, 백그라운드로 나눈 이유?
- 읽기 요청 처리와 쓰기 요청 처리 분리 위함
- 읽기 요청의 경우 바로 처리되어야 하지만, 쓰기 요청의 경우는 여러 요청을 모아서 한번에 처리해도 사용상의 문제되지 않기 때문
    
<br/><br/>

## 메모리 할당 및 사용 구조
- MySQL의 메모리 공간 : global memory 영역 / local memory 영역

### 글로벌 메모리 영역  
MySQL서버가 시작되면서 운영체제로부터 할당됨 / MySQL서버 내의 여러 thread가 공유해서 사용   
client thread 수와 무관하게 하나의 memory 영역만 할당됨    
필요에 따라 n개로 늘어날 수 있지만 client thread 수와는 무관   

- 다음과 같은 용도로 사용  
  - **InnoDB 버퍼 풀**   
  - 테이블 캐시
  - InnoDB 어댑티브 해시 인덱스
  - InnoDB 리두 로그 버퍼

<br/>

### 로컬 메모리 영역(세션 메모리 영역, 클라이언트 메모리 영역)
client thread가 query를 처리하는데 사용    
thread별로 독립적으로 사용   

- 다음과 같은 용도로 사용
  - 정렬 버퍼
  - 조인 버퍼
  - 바이너리 로그 캐시
  - 네트워크 버퍼

<br/><br/>

## MySQL의 플러그인과 컴포넌트
MySQL에서 기본적으로 제공되는 기능 외에 부가적인 기능을 더 제공하기 위한 방법   

### 플러그인   
InnoDB 또한 플러그인 형태로 제공되는 하나의 스토리지 엔진에 해당   

플러그인의 단점      
- 플러그인끼리 통신이 안됨
- 플러그인끼리의 상호 의존관계 설정이 안됨
- MySQL 서버의 변수나 함수를 직접 호출하기 때문에(=캡슐화가 안되어있어) 안전하지 않음

<br/>

### 컴포넌트     
MySQL 8.0부터 플러그인의 단점을 보완하기 위해 등장한 개념

<br/><br/>

## MySQL 쿼리 실행 구조

1. 사용자 요청
2. 쿼리파서에서 트리형태로 쿼리 재구성 => 문법오류 걸러짐
3. 전처리기 => 쿼리 구조적 오류(테이블, 컬럼 이름 검증 / 권한 검증)
4. 옵티마이저 => 쿼리를 어떻게 빠르게 처리할지 결정
5. 쿼리실행기 => 옵티마이저에서 만든 계획대로 핸들러에게 실제 요청을 주고받음
6. 스토리지엔진 => 실제 데이터를 디스크로부터 읽고 쓰는 작업 수행

<br/><br/>

- 복제(Replication) : 16장에서 다룸
- 쿼리 캐시 : 8.0버전부터 사라짐
  - 빠른 응답을 위해 SQL 실행 결과를 캐싱해두는 기능
  - 캐시 데이터와 실제 데이터가 달라지면 invalidate 해야하는데 이과정에서 성능저하 유발
- thread pool : enterprise edition에서만 지원
  - 사용 목적 : 사용자의 요청을 처리하는 포워드 스레드의 갯수를 CPU가 최대한 잘 처리할 수 있는 수준으로 줄여서 동시에 처리되는 요청이 많더라도 한정된 스레드에서 처리될 수 있도록
 
<br/><br/>

## 트랜잭션 지원 메타데이터    
스키마 정보 등 테이블의 구조정보와 같은 메타데이터들 저장   
- 이전 : 별도 파일에 저장
  - 중간에 파일 쓰다가 에러나면 트랜잭션을 지원하지 않기에 정합성 문제 발생 가능  
- 8.0버전부터 : 트랜잭션을 지원하는 InnoDB 스토리지 엔진에 테이블 형태로 저장되도록 개선됨    
  - 스키마 변경 작업중에 MySQL 서버가 비정상적으로 종료되더라도 `스키마 변경이 완전한 성공 또는 완전한 실패로 정리`될 수 있음
  - 시스템 테이블과 데이터 딕셔너리 정보를 모두 모아서 mysql 이라는 이름의 DB에 저장
  - 이 DB의 정보는 mysql.ibd 라는 이름의 테이블 스페이스에 저장됨 -> 해당 파일 잘 관리하기  

<br/><br/>

## InnoDB 스토리지 엔진 아키텍처
InnoDB는 레코드 기반의 잠금 제공함 (MySQL에서 사용할 수 있는 스토리지 엔진 중 거의 유일)     
-> 따라서, 높은 동시성 처리 가능 / 안정적 / 성능 좋음       

<img width="510" alt="스크린샷 2024-02-11 오후 5 47 26" src="https://github.com/ttaehee/book-reviews/assets/103614357/fad82809-15dc-4f6a-a25a-3834eec0e39a">

<br/><br/>

>- primary key로 data가 clustering 됨
>- 외래키를 지원함
>- MVCC를 통해 잠금없이 일관된 읽기를 지원함
>- 자동 dead lock 감지기능이 들어가있음
>- 자동으로 장애도 복구할 수 있음
>- 랜덤 디스크 쓰기 작업을 줄이기 위해 쓰기 작업을 한번에 모아서 처리하는 InnoDB 버퍼풀 존재
>- Partial page 문제를 방지하기 위한 Double Write Buffer 방식
>- Change Buffer
>- Undo Log / Redo Log 및 Log Buffer
>- Adaptive Hash Index

<br/>

### Primary 키에 의한 클러스터링   

InnoDB의 모든 테이블은 기본적으로 pk를 기준으로 클러스터링 되어 있음      
모든 secondary index는 pk의 값을 논리적인 주소로 사용함   
=> pk를 이용한 Range Scan 은 빠르게 처리 가능     

(MyISAM 스토리지 엔진에서는 클러스터링 키를 지원하지 않음    
따라서, primary key와 secondary index는 구조적으로 차이가 없음)   

<br/>

- 참고) 클러스터링이란  
  - 비슷한 데이터끼리 묶어서 보관하는 것  
  - InnoDB는 그 비슷한 기준을 정할 때 pk 기준으로 생각함 + pk를 기준으로 순서대로 디스크에 저장
    
  => pk 값에 의해 특정 레코드의 물리적인 저장 위치가 정해진다고 보면 됨     
  pk 값을 수정하게 되면 데이터의 물리적인 위치가 바뀌게 되므로 절대 하지말기     
  정확히는 DELETE 후 INSERT 진행하기

<br/><br/>

### 외래키 지원   
외래키에 대한 지원은 스토리지 엔진 레벨에서 진행됨    
= InnoDB 스토리지 엔진에서는 지원하지만 MyISAM이나 Memory 스토리지 엔진에서는 지원하지 않는 기능       

<br/>

#### 단점  
- 부모테이블과 자식테이블 모두 해당 컬럼에 인덱스 생성이 필요함   
- 데이터 변경 시에는 반드시 부모테이블이나 자식테이블에 데이터가 있는지 체크하는 작업 필요 -> 잠금이 여러 테이블에 전파되어 데드락이 발생되는 경우가 많음   

=> 외래키가 없어도 Join이 가능하기 때문에 실무에서 외래키를 사용하지 않는 경우도 있음   

<br/>

#### 외래키 체크 기능 끄기   

시스템적으로 긴급한 조치가 필요할 경우, `foreign_key_checks` 라는 시스템 변수를 OFF로 설정하여 체크 작업을 멈출 수 있음      

```
SET foreign_key_checks=OFF;
```

이런 처리를 할 경우 부가적인 체크가 필요하지 않기 때문에 빠르게 처리할 수 있으나, 부모 및 자식 테이블의 정합성 또한 수동으로 처리해주어야함   

<br/><br/>

### MVCC(Multi Version Concurrency Control)   
하나의 레코드에 대해 여러 버전이 존재하고, 필요에 따라 데이터가 어떻게 보여질지 달라지는 구조    
- MVCC의 가장 큰 목적 : Lock을 사용하지 않는 일관된 읽기를 제공하는 것   
- InnoDB는 Undo Log를 이용해 이 기능을 구현

<br/> 

- 잠금없이 일관된 읽기란?  
  - 트랜잭션 격리수준이 READ_UNCOMMITED인 예시   

<img width="386" alt="스크린샷 2024-02-11 오후 6 19 41" src="https://github.com/ttaehee/book-reviews/assets/103614357/16f87138-55cd-4280-b112-21f9b05c66fa">

=> 특정 사용자가 레코드를 변경하고 아직 커밋하지 않았다고 하더라도 이 변경 트랜잭션이 다른 사용자의 SELECT 작업을 방해하지 않음   

<br/><br/>

### 자동 데드락 감지   
- InnoDB 스토리지 엔진에서는 Lock 대기 목록을 Wait-For List로 관리함 = 잠금 대기 상황을 그래프 형태로 관리   
- 데드락 감지 스레드에서 주기적으로 이 그래프를 검사해 Deadlock(교착상태)을 감지하고 하나를 강제로 종료함    

<br/>

- 데드락에 걸린 트랜잭션 중 어느 트랜잭션을 먼저 종료할지 어떻게 결정할까?    
  - Undo Log 양이 적은 = 롤백할 때 처리할 정도가 적은 트랜잭션을 롤백처리 함    

<br/><br/>

### 자동화된 장애 복구
- MySQL이 갑자기 종료되어 완료되지 못한 트랜잭션이나 디스크에 일부만 써진 데이터(Partial Write)가 존재한다면 InnoDB는 서버를 재시작할 때 이러한 부분을 자동으로 복구함   
- 하지만 디스크나 하드웨어 이슈로 서버를 재시작 할 때도 자동으로 복구하지 못하는 경우가 있음
  - 일반적으로 부팅과 동시에 자동 복구를 시도 -> 실패 시 서버가 종료됨
    
=> `innodb_force_recovery 시스템 변수`를 설정 후 재시작해야함

- 로그 파일 손상 시 -> innodb_force_recovery를 6으로 설정 후 재시작
- 테이블 데이터 파일 손상 시 -> innodb_force_recovery를 1로 설정 후 재시작
- 어떤 부분이 손상되었는지 모를 경우 -> 1부터 6까지 변경하면서 재시작
- 그래도 재시작 안되면 -> 백업 이용해 DB 다시 구축

<br/><br/>

### InnoDB의 버퍼풀(for 데이터 캐시, 쓰기 버퍼링)
InnoDB 스토리지 엔진에서 가장 핵심적인 부분!    
- disk data file이나 index 정보를 memory에 캐시해두는 곳 + 쓰기 작업에 대한 버퍼 역할도 함 (INSERT, UPDATE, DELETE와 같은 쓰기 작업을 모아서 처리하면 랜덤 디스크 작업 횟수 감소 가능)
- 목적 : 디스크로 읽어온 페이지를 최대한 오랫동안 InnoDB 버퍼풀의 메모리에 유지해서 디스크 읽기를 최소화 하는 것 

<br/>

- 버퍼풀의 구조는 간단하게 말해서 페이징 구조를 갖고 있다고 생각하면 됨
  - innodb_page_size 시스템 변수의 설정된 크기의 여러 페이지들로 쪼개어 저장됨
  - 페이지 조각을 관리하기 위해서 LRU 리스트, Flush 리스트, Free 리스트를 관리함   

<br/><br/>

#### 버퍼풀 구조  
- 버퍼가 가득차서 비워주어야 할 때 LRU 교체 알고리즘을 적용   
  - 정확히는 LRU 알고리즘으로 작동하는 Old 서브리스트 & MRU 알고리즘으로 작동하는 New 서브리스트 두개의 리스트로 작동함   
  
참고)
- LRU(Least Recently Used) 알고리즘 : 가장 오랫동안 사용되지 않은 페이지를 먼저 교체
- MRU(More Recently Used) 알고리즘 : 가장 최근에 사용한 페이지를 먼저 교체

<br/>

<img width="632" alt="스크린샷 2024-02-11 오후 11 08 39" src="https://github.com/ttaehee/book-reviews/assets/103614357/2bb07eab-be5e-4819-813a-27e96fc093b6">

- 각 페이지는 얼마나 최근에 접근했는지에 따라 age 값 부여됨
- 새로운 페이지는 Old 리스트의 헤드부분(5/8 지점)에 추가 = 두 리스트의 중간
- 한번 읽힌 페이지는 age 초기화됨 + New 리스트의 헤드쪽으로 이동(MRU) = 승격
- 사용하지 않는 페이지는 Old 리스트의 꼬리쪽으로 이동(NRU)   
  = 쿼리에서 오랫동안 사용되지 않으면 데이터 페이지에 부여된 age가 오래되고 버퍼풀에서 페이지가 제거됨  

<br/><br/>

#### InnoDB 스토리지 엔진에서 데이터를 찾는 과정   
1)필요한 레코드가 저장된 데이터 페이지가 버퍼 풀에 있는지 검사      
- InnoDB Adaptive Hash Index 이용해 페이지 검색
- 인덱스(B-Tree)를 이용해 버퍼풀에서 페이지 검색
- 이미 데이터가 있다면 해당 페이지가 더 오래 유지되도록 작업

2)디스크에서 필요한 데이터를 버퍼 풀에 적재   
3)필요한 데이터가 자주 접근되었다면 해당 페이지의 index key를 Adaptive Hash Index에 추가      

<br/><br/>

#### 버퍼풀과 Redo Log

<img width="525" alt="스크린샷 2024-02-11 오후 11 05 28" src="https://github.com/ttaehee/book-reviews/assets/103614357/1b2497d0-7d2f-41fc-9b53-2bdbeb7ead4f">

- InnoDB의 버퍼풀은 서버의 메모리가 허용하는 만큼 크게 설정할 수록 쿼리의 성능이 올라감    
  (버퍼풀이 가져다 주는 성능상 이점인 캐시와 버퍼링 중 캐시에 도움이 되기 때문)    
  - 하지만 버퍼 풀의 기능은 데이터 캐시와 쓰기 버퍼링이 있는 만큼, 크기를 올리는 것은 전자의 성능만 올라감   
    -> 쓰기 버퍼링의 성능을 올리려면? -> Redo 로그 이해 필요

<br/>    

- Clean Page : 디스크에서 읽은 상태 그대로 변경되지 않은 데이터를 가진
- Dirty Page : INSERT, UPDATE, DELETE 명령으로 변경된 데이터를 가진 -> 언젠가는 디스크에 기록되어야함  
  - 보관될 때 Redo Log에도 그 내용을 남김 (복구 목적)
  - Redo Log는 1개 이상의 고정 크기 파일을 연결하여 순환 고리처럼 사용하고, 결국 언젠가는 기존 로그가 덮어씌어짐  

<br/>

=> Redo Log가 일정 수치로 차면 영속시키고 공간을 비우기 위해 강제로 버퍼풀의 내용을 디스크에 쓰는 작업 발생   
- Redo Log의 사이즈가 너무 작으면 이 버퍼링이 너무 자주 발생하고
- 또 너무 크면 한번에 쓰는 내용이 너무 많아짐
  
=> 적절한 Redo Log의 사이즈를 찾는 것이 중요함  

//////추가 정리하기

<br/><br/>

### Double Write Buffer
Dirty Page를 디스크로 플러시할 때 일부만 기록되는 Partial page 또는 Torn page 문제를 방지하기 위해 사용하는 버퍼   

<img width="722" alt="스크린샷 2024-02-12 오전 12 01 47" src="https://github.com/ttaehee/book-reviews/assets/103614357/ab416e1a-e858-4827-94bb-f1c9d4c01893">

실제 디스크 상의 데이터 파일에 위 그림상 A~E까지 dirty page 내용을 기록하기 전에 Double Write Buffer에 먼저 기록하고,  
쓰기 작업이 중간에 실패할 경우 버퍼 내 내용과 디스크 내 데이터 파일의 내용을 비교하여 동기화 작업을 완료함

<br/><br/>

### Undo Log








<br/><br/>

## 💡 생각해볼 점   

- 왜 Old & New 두개의 리스트로 나눈걸까?     
  - 일회성으로 많은 페이지가 캐싱될 경우 생길 수 있는 문제 방지   
    - 하나의 리스트로 단순히 LRU 교체 방식만 적용되어있다면,
      - Dump와 Where 절 없는 Select 등으로 한번에 많은 일회성 페이지들이 추가될 가능성   
      -> 자주 사용되는 페이지도 밀려서 제거될 가능성이 있기 때문

<br/>

- 성능 튜닝 관련
  - 버퍼풀의 `캐시 성능` 튜닝 = 버퍼 풀 사이즈 조절
  - 버퍼풀의 `버퍼링 성능` 튜닝 = 리두 로그 사이즈 조절
    
<br/>
