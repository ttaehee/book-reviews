## Chapter 1 : 계층형 아키텍처의 문제는 무엇일까?   

- `3계층 아키텍처` : `웹`(요청받음) -> `도메인`(비즈니스로직수행) -> `영속성`(조회 or 변경)    

  => Layered architecture의 `Layer`는 `서로 다른 레이어에 영향을 주지 않고` 독립적으로 관리 가능     
  
  - Web & Persistence layer -> Domain 레이어의 로직에 영향을 미치지 않기 때문에 => 구현 기술을 자유롭게 바꿀 수 있음    
  
    = `변화하는 요구사항과 외부요인`에 빠르게 `적응` 가능  

<br/>
   
### 계층형 아키텍처의 문제점

**1. 데이터베이스 주도 설계를 유도**  
- 전통적인 Layered Architecture는 `데이터베이스에 기초`(= 모든것이 `영속성계층을 토대`로 만들어짐)   

  => `몇가지 문제` 초래   
  
- 데이터베이스 중심적인 설계를 불러오는 요소는 `ORM 프레임워크를 사용`하는 것  

  - 비지니스 관점에서 우리는 `도메인 로직 -> 데이터베이스 모델링`의 순서로 만들어야 함   
    그러나, 우리는 대체로 `데이터베이스 모델링 -> 도메인 로직` 순서로 개발   
    이러한 이유는 ORM 프레임워크 사용을 하기 때문   

  - `ORM 프레임워크 + Layered Architecture` 함께 사용 -> Persistence 측면에서 비즈니스 로직을 녹일 우려가 있음      
  
    = Domain layer의 `Entity & Persistence layer` `강한 결합`을 이끌게 됨     
  - Persistence layer의 코드가 사실상 Domain layer의 코드에 통합되어 있기 때문에   
   
    => 다른 코드가 없으면 어느 하나 `변경하기 어렵게` 만듬      

<br/>

**2. 지름길을 택하기 쉬워짐**  
- Layered Architecture에서 규칙은 기본적으로 하위 바탕이 되는, 의존하고 있는 레이어에는 접근을 허용     
  - 만약, 상위 계층에 위치한 컴포넌트에 접근해야한다면 해당 컴포넌트를 아래 계층으로 내리면 해결     
    (이러한 방법이 여기서 말하는 `지름길`인듯!, 접근을 해야 하는 클래스가 있다면 `단순히 하위 계층으로 내리는` 것)
    
  - 하위 계층으로 내리려는 컴포넌트가 이미 상위 계층에 다른 컴포넌트에 의존성이 있다면?    
    - 하위 -> 상위로 접근하는 상황이 발생할 듯

- Layered Architectured에서 이 룰을 강제하지 않음
  - 때문에 레이어에 어울리지 않는 각종 컴포넌트, 유틸 클래스 등이 하위 레이어에 몰릴 수 있음
  - Persistence 레이어(최 하단 계층)에 어떤 계층에도 속하지 않는 것처럼 보이는 `헬퍼 컴포넌트나 유틸리티 컴포넌트`들이 이처럼 `아래 계층으로 내릴 가능성`이 커 `모든것이 몰려있는` 기이한 현상이 나타날 수 있음  
  
- 우리 아키텍처에서 위와 같은 현상을 막길 원한다면 아키텍처 룰을 통해 강제하거나 만약 강제하지 못한다면 레이어는 최선이 아닐 수 있음
  - 하위 -> 상위 계층으로 접근하면 안되도록 처리가 필요함

<br/>

**3. 테스트하기 어려움(서비스 계층을 스킵하는 경우)**   
- `계층을 건너뛰는` 일이 생김(웹 -> (도메인 X) -> 바로 영속성객체 접근) 
 
  => `기능 확장`에 문제(핵심 도메인 로직들 퍼질 확률이 높음) + Web layer `테스트 시` 도메인, 영속성 layer mocking 필요 -> `복잡`   

<br/>

**4. 유즈케이스를 숨김**   
- `기능 추가 or 변경`할 때 -> 올바른 `위치` 찾아야함
  - 때문에 Architecture는 이를 빠르게 찾도록 도와줄 수 있어야함
  - `Layered Architecture`는 이를 얼마나 도와줄 수 있나  

<br/>   

- 앞서 본 것처럼 Layered Architecture는 도메인 로직이 여러 레이어에 걸쳐서 쉽게 흩어질 수 있음
  
  => 새로운 기능 추가 시 올바른 위치 찾기를 어렵게 만듬
  
- Layered Architecture는 도메인 서비스의 크기에 대해서 어떠한 룰로 강제를 하지 않음  
  - 이는 `하나의 도메인 서비스`가 `여러 Use Case에 대한 도메인 로직`을 가질 수 있다는 의미이고 그만큼 `비대해진다`는 의미
  - 비대해진 서비스는 `너무 많은 의존성`을 가짐   
  
  => `테스트 어렵게 만듬 + Use Case를 담당하는 서비스를 찾기 어렵게` 만듬

<br/>

**5. 동시작업이 어려워짐**    
- 서로 다른 Use Case에 대한 작업하면 -> 같은 서비스를 동시에 편집하는 상황 발생   

  => 병합충돌, 잠재적으로 이전코드로 되돌려야하는 문제 야기   

<br/>

### 마무리  
- Layered Architecture는 위와 같은 문제가 있지만,    
  `올바르게 구축`하며 `엄격한 규칙`을 적용하면 `유지보수 쉬운 + 코드변경 추가 쉬운` 아키텍처 될 수 있음    
  - 그러나 이는, 그만큼 Layered Architecture는 `잘못된 것들을 허용`한다는 것을 의미    
    (Layered Architecture는 많은것들이 잘못된 방향으로 흘러가도록 용인함)       

=> Layered Architecture의 `문제점을 염두`하면서 `엄격한 자기훈련`을 통해 개발한다면,   
보다 유지보수하기 좋은 소프트웨어를 구축하는데 도움 줄 수 있음  



